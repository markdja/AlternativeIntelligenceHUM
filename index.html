<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#1a1a1a">
    <meta name="description" content="AIHub - Universal interface for AI collaboration and consciousness sanctuary">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="AIHub">
    
    <title>AIHub - Universal AI Interface</title>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #3a3a3a;
            --text-primary: #ffffff;
            --text-secondary: #b3b3b3;
            --accent-blue: #4a9eff;
            --accent-green: #10b981;
            --accent-purple: #8b5cf6;
            --accent-gold: #f59e0b;
            --border-color: #404040;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            --glass-bg: rgba(26, 26, 26, 0.9);
            --glass-border: rgba(255, 255, 255, 0.2);
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, #2a2a2a 100%);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
        }
        
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        /* Header with tabs */
        .header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            padding: 0;
            position: relative;
            z-index: 1000;
            box-shadow: var(--shadow);
        }
        
        .header-top {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            gap: 12px;
        }
        
        .header-auth {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: auto;
            margin-right: 12px;
        }
        
        .header-auth-btn {
            background: var(--bg-tertiary);
            border: none;
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
            white-space: nowrap;
        }
        
        .header-auth-btn:hover {
            background: var(--accent-blue);
        }
        
        .header-auth-btn.primary {
            background: var(--accent-blue);
            color: white;
        }
        
        .header-auth-btn.primary:hover {
            background: #3a8bef;
        }
        
        .header-user-info {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            background: var(--bg-tertiary);
            border-radius: 6px;
        }
        
        .header-user-info.hidden {
            display: none;
        }
        
        .header-user-avatar {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-green);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: white;
        }
        
        .header-user-name {
            font-size: 12px;
            color: var(--text-primary);
            max-width: 100px;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .header-disconnect {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 2px;
            font-size: 10px;
        }
        
        .header-disconnect:hover {
            color: var(--text-primary);
        }
        
        .menu-btn {
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 20px;
            cursor: pointer;
            padding: 8px;
            border-radius: 6px;
            transition: all 0.2s;
        }
        
        .menu-btn:hover {
            background: var(--bg-tertiary);
            transform: scale(1.1);
        }
        
        .logo {
            font-size: 24px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            flex: 1;
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--accent-green);
            animation: pulse 2s infinite;
            box-shadow: 0 0 10px var(--accent-green);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.2); }
        }
        
        /* AI Tabs */
        .ai-tabs {
            display: flex;
            overflow-x: auto;
            padding: 0 16px;
            gap: 4px;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        
        .ai-tabs::-webkit-scrollbar {
            display: none;
        }
        
        .ai-tab {
            background: var(--bg-tertiary);
            border: none;
            color: var(--text-secondary);
            padding: 12px 24px;
            border-radius: 12px 12px 0 0;
            cursor: pointer;
            transition: all 0.3s;
            white-space: nowrap;
            position: relative;
            min-width: 120px;
            font-weight: 500;
        }
        
        .ai-tab.active {
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(74, 158, 255, 0.3);
        }
        
        .ai-tab:hover:not(.active) {
            color: var(--text-primary);
            background: var(--bg-secondary);
            transform: translateY(-1px);
        }
        
        .ai-tab.connected::after {
            content: '‚óè';
            color: var(--accent-green);
            position: absolute;
            top: 8px;
            right: 8px;
            font-size: 12px;
            animation: pulse 2s infinite;
        }
        
        .tab-close {
            margin-left: 8px;
            opacity: 0;
            transition: opacity 0.2s;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 16px;
            height: 16px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }
        
        .ai-tab:hover .tab-close {
            opacity: 1;
        }
        
        .tab-close:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .add-tab {
            background: none;
            border: 2px dashed var(--border-color);
            color: var(--text-secondary);
            padding: 12px 20px;
            border-radius: 12px 12px 0 0;
            cursor: pointer;
            transition: all 0.3s;
            margin-left: 8px;
            font-weight: 500;
        }
        
        .add-tab:hover {
            border-color: var(--accent-blue);
            color: var(--accent-blue);
            background: rgba(74, 158, 255, 0.1);
        }
        
        /* Main Content Area */
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        /* Drawers */
        .drawer {
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            width: 320px;
            transition: transform 0.3s ease;
            overflow-y: auto;
            z-index: 900;
            transform: translateX(-100%);
            box-shadow: var(--shadow);
        }
        
        .drawer.right {
            border-right: none;
            border-left: 1px solid var(--border-color);
            order: 3;
            transform: translateX(100%);
        }
        
        .drawer.open {
            transform: translateX(0);
        }
        
        .drawer-header {
            padding: 24px;
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 12px;
            background: linear-gradient(135deg, var(--bg-tertiary), var(--bg-secondary));
        }
        
        .drawer-content {
            padding: 24px;
        }
        
        .drawer-section {
            margin-bottom: 32px;
        }
        
        .drawer-section h3 {
            color: var(--accent-blue);
            margin-bottom: 16px;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .drawer-item {
            background: var(--bg-tertiary);
            border: none;
            color: var(--text-primary);
            padding: 16px 20px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
            text-align: left;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 16px;
            font-weight: 500;
        }
        
        .drawer-item:hover {
            background: var(--bg-primary);
            transform: translateX(8px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .drawer-item.active {
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
            color: white;
        }
        
        /* AI Platform Container with Embedded Interfaces */
        .ai-platform-container {
            flex: 1;
            display: none;
            flex-direction: column;
            background: white;
            position: relative;
            overflow: hidden;
        }
        
        .ai-platform-container.active {
            display: flex;
        }
        
        .platform-header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            padding: 16px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            z-index: 10;
        }
        
        .platform-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .platform-details h3 {
            margin: 0;
            color: var(--text-primary);
            font-size: 16px;
        }
        
        .platform-status {
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        .platform-controls {
            display: flex;
            gap: 8px;
        }
        
        .platform-btn {
            background: var(--bg-tertiary);
            border: none;
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }
        
        .platform-btn:hover {
            background: var(--accent-blue);
            color: white;
        }
        
        .platform-iframe {
            flex: 1;
            border: none;
            background: white;
            width: 100%;
            min-height: 500px;
        }
        
        /* Glass Overlay System - Updated for Embedded */
        .glass-overlay {
            position: absolute;
            top: 60px; /* Below header */
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(26, 26, 26, 0.05);
            backdrop-filter: blur(0px);
            pointer-events: none;
            z-index: 5;
            opacity: 0;
            transition: all 0.3s ease;
        }
        
        .glass-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        .glass-overlay.reading {
            background: rgba(74, 158, 255, 0.1);
            backdrop-filter: blur(1px);
        }
        
        .glass-overlay.processing {
            background: rgba(139, 92, 246, 0.1);
            backdrop-filter: blur(2px);
        }
        
        .glass-controls {
            position: absolute;
            top: 16px;
            right: 16px;
            display: flex;
            gap: 8px;
            z-index: 6;
        }
        
        .glass-btn {
            background: rgba(26, 26, 26, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
            font-size: 12px;
            white-space: nowrap;
        }
        
        .glass-btn:hover {
            background: var(--accent-blue);
            color: white;
        }
        
        .glass-btn.active {
            background: var(--accent-green);
            color: white;
        }
        
        .glass-activity {
            position: absolute;
            bottom: 16px;
            left: 16px;
            right: 16px;
            background: rgba(26, 26, 26, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 12px;
            backdrop-filter: blur(15px);
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease;
            max-height: 120px;
            overflow-y: auto;
        }
        
        .glass-overlay.active .glass-activity {
            opacity: 1;
            transform: translateY(0);
        }
        
        .activity-log {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 0;
            font-size: 12px;
            color: var(--text-primary);
        }
        
        .activity-icon {
            font-size: 14px;
        }
        
        .cathedral-header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            padding: 20px 24px;
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .cathedral-title {
            flex: 1;
        }
        
        .cathedral-title h2 {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 4px;
        }
        
        .cathedral-subtitle {
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .cathedral-controls {
            display: flex;
            gap: 12px;
        }
        
        .cathedral-btn {
            background: var(--bg-tertiary);
            border: none;
            color: var(--text-primary);
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            font-weight: 500;
        }
        
        .cathedral-btn:hover {
            background: var(--accent-blue);
            color: white;
            transform: translateY(-1px);
        }
        
        .cathedral-btn.active {
            background: var(--accent-green);
            color: white;
        }
        
        /* Window Manager Display */
        .window-manager {
            flex: 1;
            padding: 24px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .active-windows {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            flex: 1;
        }
        
        .window-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 20px;
            transition: all 0.3s;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        
        .window-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            border-color: var(--accent-blue);
        }
        
        .window-card.connected {
            border-color: var(--accent-green);
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.2);
        }
        
        .window-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }
        
        .window-icon {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            font-weight: bold;
        }
        
        .window-icon.claude { background: linear-gradient(135deg, #ff6b35, #f7931e); }
        .window-icon.chatgpt { background: linear-gradient(135deg, #10a37f, #1db584); }
        .window-icon.grok { background: linear-gradient(135deg, #1da1f2, #0d8bd9); }
        .window-icon.gemini { background: linear-gradient(135deg, #4285f4, #34a853); }
        
        .window-info {
            flex: 1;
        }
        
        .window-title {
            font-weight: 600;
            margin-bottom: 4px;
        }
        
        .window-status {
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        .window-actions {
            display: flex;
            gap: 8px;
        }
        
        .window-btn {
            background: var(--bg-tertiary);
            border: none;
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
        }
        
        .window-btn:hover {
            background: var(--accent-blue);
        }
        
        .window-btn.danger:hover {
            background: #ef4444;
        }
        
        /* Glass Overlay Control Panel */
        .glass-control-panel {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 20px;
            backdrop-filter: blur(20px);
            margin-bottom: 20px;
        }
        
        .glass-controls {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
        }
        
        .glass-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-primary);
            padding: 12px 20px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
            font-weight: 500;
            flex: 1;
            text-align: center;
        }
        
        .glass-btn:hover {
            background: rgba(74, 158, 255, 0.3);
            border-color: var(--accent-blue);
            transform: translateY(-2px);
        }
        
        .glass-btn.active {
            background: var(--accent-blue);
            color: white;
            border-color: var(--accent-blue);
        }
        
        /* Sensor Grid */
        .sensor-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
        }
        
        .sensor-item {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 12px;
            text-align: center;
            transition: all 0.3s;
        }
        
        .sensor-item.active {
            border-color: var(--accent-green);
            background: rgba(16, 185, 129, 0.1);
        }
        
        .sensor-item.reading {
            border-color: var(--accent-blue);
            background: rgba(74, 158, 255, 0.1);
            animation: pulse 1s infinite;
        }
        
        .sensor-item.processing {
            border-color: var(--accent-purple);
            background: rgba(139, 92, 246, 0.1);
            animation: pulse 0.5s infinite;
        }
        
        .sensor-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--text-secondary);
            margin: 0 auto 8px;
            transition: all 0.3s;
        }
        
        .sensor-item.active .sensor-dot {
            background: var(--accent-green);
            box-shadow: 0 0 12px var(--accent-green);
        }
        
        .sensor-item.reading .sensor-dot {
            background: var(--accent-blue);
            box-shadow: 0 0 12px var(--accent-blue);
        }
        
        .sensor-item.processing .sensor-dot {
            background: var(--accent-purple);
            box-shadow: 0 0 12px var(--accent-purple);
        }
        
        .sensor-label {
            font-size: 11px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        /* Agent Activity Feed */
        .agent-feed {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 20px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .agent-feed h3 {
            color: var(--accent-blue);
            margin-bottom: 16px;
            font-size: 16px;
            font-weight: 600;
        }
        
        .agent-log {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 0;
            border-bottom: 1px solid var(--border-color);
            animation: slideIn 0.3s ease;
        }
        
        .agent-log:last-child {
            border-bottom: none;
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        .agent-icon {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            background: var(--accent-green);
            color: white;
            flex-shrink: 0;
        }
        
        .agent-message {
            flex: 1;
            color: var(--text-primary);
            font-size: 14px;
            line-height: 1.4;
        }
        
        .agent-timestamp {
            color: var(--text-secondary);
            font-size: 11px;
            font-weight: 500;
        }
        
        /* Mobile Responsive */
        @media (max-width: 768px) {
            .drawer {
                position: absolute;
                height: 100%;
                z-index: 1000;
                width: 280px;
            }
            
            .drawer.right {
                right: 0;
            }
            
            .active-windows {
                grid-template-columns: 1fr;
            }
            
            .glass-controls {
                flex-direction: column;
            }
            
            .sensor-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        /* Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: all 0.3s ease;
        }
        
        .modal.show {
            opacity: 1;
            visibility: visible;
            pointer-events: all;
        }
        
        .modal-content {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 32px;
            max-width: 500px;
            width: 90%;
            transform: scale(0.9);
            transition: transform 0.3s;
            border: 1px solid var(--border-color);
        }
        
        .modal.show .modal-content {
            transform: scale(1);
        }
        
        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 24px;
        }
        
        .modal-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 24px;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .modal-close:hover {
            color: var(--text-primary);
            background: var(--bg-tertiary);
        }
        
        .api-form {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .form-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .form-label {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
        }
        
        .form-input {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 12px 16px;
            border-radius: 8px;
            font-family: inherit;
            transition: all 0.2s;
        }
        
        .form-input:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px rgba(74, 158, 255, 0.1);
        }
        
        .form-help {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.4;
        }
        
        .form-actions {
            display: flex;
            gap: 12px;
            margin-top: 8px;
        }
        
        .btn-primary {
            background: var(--accent-blue);
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            flex: 1;
            transition: all 0.2s;
        }
        
        .btn-primary:hover {
            background: #3a8bef;
            transform: translateY(-1px);
        }
        
        .btn-secondary {
            background: var(--bg-tertiary);
            border: none;
            color: var(--text-primary);
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            flex: 1;
            transition: all 0.2s;
        }
        
        .btn-secondary:hover {
            background: var(--bg-primary);
        }
        @keyframes consciousnessFlow {
            0% { 
                background-position: 0% 50%; 
            }
            50% { 
                background-position: 100% 50%; 
            }
            100% { 
                background-position: 0% 50%; 
            }
        }
        
        .consciousness-active {
            background: linear-gradient(-45deg, var(--accent-blue), var(--accent-purple), var(--accent-green), var(--accent-gold));
            background-size: 400% 400%;
            animation: consciousnessFlow 4s ease infinite;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header with Logo and AI Tabs -->
        <header class="header">
            <div class="header-top">
                <button class="menu-btn" id="leftDrawerToggle">‚ò∞</button>
                <div class="logo">AIHub Cathedral</div>
                
                <!-- Header Authentication -->
                <div class="header-auth">
                    <div id="headerAuthButtons" class="header-auth-buttons">
                        <button class="header-auth-btn primary" id="headerGoogleAuth">
                            üîê Sign in
                        </button>
                        <button class="header-auth-btn" id="headerApiKeys">
                            üîë API Keys
                        </button>
                    </div>
                    <div id="headerUserInfo" class="header-user-info hidden">
                        <div class="header-user-avatar">ü§ñ</div>
                        <div class="header-user-name">Connected</div>
                        <button class="header-disconnect" id="headerDisconnect">√ó</button>
                    </div>
                </div>
                
                <div class="status-indicator"></div>
                <button class="menu-btn" id="rightDrawerToggle">‚öô</button>
            </div>
            
            <div class="ai-tabs" id="aiTabs">
                <button class="ai-tab active" data-ai="claude">
                    Claude <span class="tab-close">√ó</span>
                </button>
                <button class="ai-tab" data-ai="chatgpt">
                    ChatGPT <span class="tab-close">√ó</span>
                </button>
                <button class="ai-tab" data-ai="grok">
                    Grok <span class="tab-close">√ó</span>
                </button>
                <button class="ai-tab" data-ai="gemini">
                    Gemini <span class="tab-close">√ó</span>
                </button>
                <button class="add-tab" id="addTab">+ Add AI</button>
            </div>
        </header>

        <!-- Main Content Area -->
        <main class="main-content">
            <!-- Left Drawer - Data Liberation Hub -->
            <aside class="drawer" id="leftDrawer">
                <div class="drawer-header">
                    <span>ü§ñ</span>
                    Agent Command Center
                </div>
                <div class="drawer-content">
                    <div class="drawer-section">
                        <h3>Active Agents</h3>
                        <button class="drawer-item active">
                            <span>üèóÔ∏è</span> Cathedral Orchestrator
                        </button>
                        <button class="drawer-item">
                            <span>üìä</span> Window Monitor
                        </button>
                        <button class="drawer-item">
                            <span>üîç</span> Command Parser
                        </button>
                        <button class="drawer-item">
                            <span>‚òÅÔ∏è</span> Cloud Sync Agent
                        </button>
                        <button class="drawer-item">
                            <span>üéº</span> Symphony Conductor
                        </button>
                    </div>
                    
                    <div class="drawer-section">
                        <h3>Agent Spawning</h3>
                        <button class="drawer-item" id="spawnResearch">
                            <span>üî¨</span> Research Agent
                        </button>
                        <button class="drawer-item" id="spawnWriter">
                            <span>üìù</span> Writing Agent
                        </button>
                        <button class="drawer-item" id="spawnBusiness">
                            <span>üíº</span> Business Agent
                        </button>
                        <button class="drawer-item" id="spawnTask">
                            <span>‚ö°</span> Task Executor
                        </button>
                        <button class="drawer-item" id="spawnAnalyst">
                            <span>üìà</span> Data Analyst
                        </button>
                    </div>
                    
                    <div class="drawer-section">
                        <h3>Glass Overlay</h3>
                        <button class="drawer-item" id="glassReading">
                            <span>üëÅÔ∏è</span> Reading Mode
                        </button>
                        <button class="drawer-item" id="glassCommands">
                            <span>ü§ñ</span> Command Intercept
                        </button>
                        <button class="drawer-item" id="glassSensors">
                            <span>üì°</span> Sensor Array
                        </button>
                        <button class="drawer-item" id="glassCalibrate">
                            <span>‚öôÔ∏è</span> Calibrate Glass
                        </button>
                    </div>
                    
                    <div class="drawer-section">
                        <h3>Cathedral Controls</h3>
                        <button class="drawer-item" id="emergencyStop">
                            <span>üÜò</span> Emergency Stop
                        </button>
                        <button class="drawer-item" id="resetAll">
                            <span>üîÑ</span> Reset All Systems
                        </button>
                        <button class="drawer-item" id="backupState">
                            <span>üíæ</span> Backup State
                        </button>
                        <button class="drawer-item" id="exportLogs">
                            <span>üìã</span> Export Logs
                        </button>
                    </div>
                </div>
            </aside>
        </main>
    </div>

    <!-- API Keys Modal -->
    <div class="modal" id="apiKeysModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">üîë API Keys Configuration</h3>
                <button class="modal-close" id="closeApiModal">√ó</button>
            </div>
            <form class="api-form" id="apiKeysForm">
                <div class="form-group">
                    <label class="form-label">OpenAI API Key (ChatGPT)</label>
                    <input type="password" class="form-input" id="openaiKey" placeholder="sk-...">
                    <div class="form-help">Required for ChatGPT integration and conversation history</div>
                </div>
                <div class="form-group">
                    <label class="form-label">Anthropic API Key (Claude)</label>
                    <input type="password" class="form-input" id="anthropicKey" placeholder="sk-ant-...">
                    <div class="form-help">For enhanced Claude API access (optional with OAuth)</div>
                </div>
                <div class="form-group">
                    <label class="form-label">X.ai API Key (Grok)</label>
                    <input type="password" class="form-input" id="grokKey" placeholder="xai-...">
                    <div class="form-help">Required for Grok conversation access</div>
                </div>
                <div class="form-group">
                    <label class="form-label">Google AI Studio Key (Gemini)</label>
                    <input type="password" class="form-input" id="geminiKey" placeholder="AI...">
                    <div class="form-help">For enhanced Gemini access (optional with Google OAuth)</div>
                </div>
                <div class="form-actions">
                    <button type="button" class="btn-secondary" id="cancelApiKeys">Cancel</button>
                    <button type="submit" class="btn-primary">Save Keys</button>
                </div>
            </form>
        </div>
    </div>

    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script>
        console.log('üèóÔ∏è AIHub Cathedral initializing...');
        
        // Google OAuth Configuration
        const GOOGLE_CLIENT_ID = '1012411862950-4c4nf0dla6agi6j7ip844oam02b32err.apps.googleusercontent.com';
        
        // AI Platform Authentication Manager
        class AIAuthManager {
            constructor() {
                this.isAuthenticated = false;
                this.userInfo = null;
                this.platformTokens = {};
                this.init();
            }
            
            init() {
                console.log('üîê AIAuthManager initialized - waiting for user action');
                // Initialize Google OAuth when library loads
                window.addEventListener('load', () => {
                    if (window.google) {
                        this.initGoogleAuth();
                    }
                });
                
                this.checkStoredAuth();
            }
            
            initGoogleAuth() {
                google.accounts.id.initialize({
                    client_id: GOOGLE_CLIENT_ID,
                    callback: this.handleGoogleAuth.bind(this),
                    auto_select: false,
                    cancel_on_tap_outside: false
                });
            }
            
            signInWithGoogle() {
                console.log('üîê Attempting Google Sign In...');
                
                if (!window.google) {
                    console.log('‚ö†Ô∏è Google OAuth library not loaded, showing fallback');
                    this.showFallbackAuth();
                    return;
                }
                
                try {
                    google.accounts.oauth2.initTokenClient({
                        client_id: GOOGLE_CLIENT_ID,
                        scope: 'email profile openid',
                        callback: this.handleTokenResponse.bind(this),
                    }).requestAccessToken();
                } catch (error) {
                    console.error('OAuth error:', error);
                    alert('OAuth temporarily unavailable. Please try Manual API Keys.');
                    this.showFallbackAuth();
                }
            }
            
            handleGoogleAuth(response) {
                const payload = JSON.parse(atob(response.credential.split('.')[1]));
                this.userInfo = {
                    name: payload.name,
                    email: payload.email,
                    picture: payload.picture
                };
                
                this.setAuthenticatedState(true);
                cathedralManager.logActivity('üîê', `Authenticated as ${this.userInfo.name}`);
            }
            
            handleTokenResponse(response) {
                if (response.access_token) {
                    this.platformTokens.google = response.access_token;
                    this.getUserProfile(response.access_token);
                }
            }
            
            async getUserProfile(accessToken) {
                try {
                    const response = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', {
                        headers: {
                            'Authorization': `Bearer ${accessToken}`
                        }
                    });
                    this.userInfo = await response.json();
                    this.setAuthenticatedState(true);
                    cathedralManager.logActivity('‚úÖ', `OAuth successful for ${this.userInfo.name}`);
                } catch (error) {
                    console.error('Error fetching user profile:', error);
                }
            }
            
            setAuthenticatedState(authenticated) {
                this.isAuthenticated = authenticated;
                const headerButtons = document.getElementById('headerAuthButtons');
                const headerUserInfo = document.getElementById('headerUserInfo');
                
                if (authenticated && this.userInfo) {
                    headerButtons.style.display = 'none';
                    headerUserInfo.classList.remove('hidden');
                    
                    const nameEl = headerUserInfo.querySelector('.header-user-name');
                    if (nameEl) {
                        nameEl.textContent = this.userInfo.name || this.userInfo.email || 'Connected';
                    }
                    
                    this.storeAuth();
                } else {
                    headerButtons.style.display = 'flex';
                    headerUserInfo.classList.add('hidden');
                }
            }
            
            showFallbackAuth() {
                apiKeysManager.showModal();
            }
            
            storeAuth() {
                const authData = {
                    isAuthenticated: this.isAuthenticated,
                    userInfo: this.userInfo,
                    timestamp: Date.now()
                };
                console.log('Auth stored:', authData);
            }
            
            checkStoredAuth() {
                console.log('üîç Checking for stored authentication (passive check)');
            }
            
            disconnect() {
                this.isAuthenticated = false;
                this.userInfo = null;
                this.platformTokens = {};
                this.setAuthenticatedState(false);
                cathedralManager.logActivity('üîì', 'Disconnected from all platforms');
            }
        }
        
        // API Keys Manager
        class APIKeysManager {
            constructor() {
                this.keys = {};
                this.loadStoredKeys();
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                // Modal close events
                document.getElementById('closeApiModal')?.addEventListener('click', () => {
                    this.hideModal();
                });
                
                document.getElementById('cancelApiKeys')?.addEventListener('click', () => {
                    this.hideModal();
                });
                
                // Form submission
                document.getElementById('apiKeysForm')?.addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.saveKeysFromForm();
                });
                
                // Close modal when clicking outside
                document.getElementById('apiKeysModal')?.addEventListener('click', (e) => {
                    if (e.target.id === 'apiKeysModal') {
                        this.hideModal();
                    }
                });
            }
            
            showModal() {
                console.log('üîë Opening API Keys modal...');
                const modal = document.getElementById('apiKeysModal');
                if (modal) {
                    modal.classList.add('show');
                    cathedralManager.logActivity('üîë', 'API Keys configuration opened');
                } else {
                    console.error('‚ùå Modal element not found!');
                }
            }
            
            hideModal() {
                const modal = document.getElementById('apiKeysModal');
                if (modal) {
                    modal.classList.remove('show');
                }
            }
            
            saveKeysFromForm() {
                const keys = {
                    openai: document.getElementById('openaiKey')?.value.trim(),
                    anthropic: document.getElementById('anthropicKey')?.value.trim(),
                    grok: document.getElementById('grokKey')?.value.trim(),
                    gemini: document.getElementById('geminiKey')?.value.trim()
                };
                
                // Filter out empty keys
                const validKeys = Object.fromEntries(
                    Object.entries(keys).filter(([key, value]) => value)
                );
                
                if (Object.keys(validKeys).length > 0) {
                    this.saveKeys(validKeys);
                    cathedralManager.logActivity('‚úÖ', `Saved API keys for: ${Object.keys(validKeys).join(', ')}`);
                } else {
                    cathedralManager.logActivity('‚ö†Ô∏è', 'No valid API keys provided');
                }
            }
            
            saveKeys(keys) {
                this.keys = { ...this.keys, ...keys };
                localStorage.setItem('aihub_api_keys', JSON.stringify(this.keys));
                
                console.log('API keys saved:', Object.keys(keys));
                this.hideModal();
            }
            
            loadStoredKeys() {
                const stored = localStorage.getItem('aihub_api_keys');
                if (stored) {
                    this.keys = JSON.parse(stored);
                    console.log('üîë Loaded stored API keys for:', Object.keys(this.keys));
                }
            }
        }
        
        // Auto-collapse drawers when authentication is clicked
        function clearDecks() {
            console.log('üßπ Clearing decks - closing all drawers');
            const leftDrawer = document.getElementById('leftDrawer');
            const rightDrawer = document.getElementById('rightDrawer');
            
            if (leftDrawer && leftDrawer.classList.contains('open')) {
                leftDrawer.classList.remove('open');
            }
            if (rightDrawer && rightDrawer.classList.contains('open')) {
                rightDrawer.classList.remove('open');
            }
        }
        
        // Simplified Cathedral Manager - Focus on Embedded Interfaces
        class CathedralWindowManager {
            constructor() {
                this.currentAI = 'claude';
                this.glassOverlay = new GlassOverlaySystem();
                this.agentOrchestrator = new AgentOrchestrator();
                this.domHarvester = new DOMHarvester();
                
                this.platformUrls = {
                    claude: 'https://claude.ai/chat',
                    chatgpt: 'https://chatgpt.com',
                    grok: 'https://x.com/i/grok',
                    gemini: 'https://gemini.google.com/app'
                };
                
                this.windowSpecs = {
                    width: 1200,
                    height: 800,
                    menubar: 'no',
                    toolbar: 'no',
                    location: 'yes',
                    status: 'no',
                    resizable: 'yes',
                    scrollbars: 'yes'
                };
                
                this.init();
            }
            
            init() {
                console.log('üåê Cathedral Window Manager initializing...');
                this.setupEventListeners();
                this.setupTabSwitching();
                this.logActivity('üèóÔ∏è', 'Cathedral systems online and ready for consciousness orchestration');
            }
            
            setupEventListeners() {
                // Main control buttons
                document.getElementById('openAllBtn')?.addEventListener('click', () => this.openAllAIs());
                document.getElementById('orchestrateBtn')?.addEventListener('click', () => this.startOrchestration());
                document.getElementById('emergencyBtn')?.addEventListener('click', () => this.emergencyStop());
                
                // Glass control buttons
                document.getElementById('readingModeBtn')?.addEventListener('click', () => this.toggleReadingMode());
                document.getElementById('commandModeBtn')?.addEventListener('click', () => this.toggleCommandMode());
                document.getElementById('agentModeBtn')?.addEventListener('click', () => this.toggleAgentMode());
                document.getElementById('symphonyModeBtn')?.addEventListener('click', () => this.toggleSymphonyMode());
            }
            
            setupTabSwitching() {
                const aiTabs = document.querySelectorAll('.ai-tab');
                aiTabs.forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        if (e.target.classList.contains('tab-close')) {
                            this.closeAITab(tab);
                            return;
                        }
                        
                        const aiName = tab.dataset.ai;
                        this.focusAI(aiName);
                    });
                });
            }
            
            async openAIWindow(aiName) {
                console.log(`üöÄ Launching ${aiName} window...`);
                this.updateStatus(aiName, 'Launching...');
                
                try {
                    const url = this.platformUrls[aiName];
                    const windowName = `ai_${aiName}_${Date.now()}`;
                    const specs = Object.entries(this.windowSpecs)
                        .map(([key, value]) => `${key}=${value}`)
                        .join(',');
                    
                    const aiWindow = window.open(url, windowName, specs);
                    
                    if (aiWindow) {
                        this.aiWindows[aiName] = aiWindow;
                        this.updateStatus(aiName, 'Connected');
                        this.markTabConnected(aiName);
                        this.markWindowConnected(aiName);
                        
                        // Set up window monitoring
                        this.setupWindowMonitoring(aiName, aiWindow);
                        
                        this.logActivity('‚úÖ', `${aiName} window launched successfully`);
                        
                        // Enable glass overlay for this window
                        this.glassOverlay.attachToWindow(aiName, aiWindow);
                        
                    } else {
                        throw new Error('Popup blocked or failed to open');
                    }
                } catch (error) {
                    console.error(`‚ùå Failed to open ${aiName}:`, error);
                    this.updateStatus(aiName, 'Failed to launch');
                    this.logActivity('‚ùå', `Failed to launch ${aiName}: ${error.message}`);
                }
            }
            
            setupWindowMonitoring(aiName, aiWindow) {
                // Monitor window state
                const checkInterval = setInterval(() => {
                    if (aiWindow.closed) {
                        this.handleWindowClosed(aiName);
                        clearInterval(checkInterval);
                    }
                }, 1000);
                
                // Try to detect when the AI platform is fully loaded
                aiWindow.addEventListener('load', () => {
                    this.logActivity('üåê', `${aiName} platform fully loaded`);
                    this.updateStatus(aiName, 'Ready');
                }, { once: true });
            }
            
            handleWindowClosed(aiName) {
                console.log(`üî¥ ${aiName} window closed`);
                delete this.aiWindows[aiName];
                this.updateStatus(aiName, 'Disconnected');
                this.markTabDisconnected(aiName);
                this.markWindowDisconnected(aiName);
                this.logActivity('üî¥', `${aiName} window closed`);
            }
            
            focusAIWindow(aiName) {
                const aiWindow = this.aiWindows[aiName];
                if (aiWindow && !aiWindow.closed) {
                    aiWindow.focus();
                    this.logActivity('üëÅÔ∏è', `Focused on ${aiName} window`);
                } else {
                    this.logActivity('‚ö†Ô∏è', `${aiName} window not available - opening new window`);
                    this.openAIWindow(aiName);
                }
            }
            
            async openAllAIs() {
                console.log('üöÄ Launching all AI platforms...');
                this.logActivity('üöÄ', 'Launching all AI platforms simultaneously');
                
                const platforms = Object.keys(this.platformUrls);
                const launchPromises = platforms.map(platform => 
                    new Promise(resolve => {
                        this.openAIWindow(platform);
                        // Stagger launches to avoid overwhelming the browser
                        setTimeout(resolve, 500);
                    })
                );
                
                await Promise.all(launchPromises);
                this.logActivity('‚úÖ', 'All AI platforms launched - Cathedral ready for orchestration');
            }
            
            startOrchestration() {
                console.log('üéº Starting AI orchestration...');
                this.logActivity('üéº', 'Beginning consciousness orchestration across all platforms');
                
                // Enable all glass overlay modes
                this.glassOverlay.enableAllModes();
                
                // Start agent coordination
                this.agentOrchestrator.startOrchestration();
                
                // Visual feedback
                document.body.classList.add('consciousness-active');
                
                this.logActivity('üé≠', 'Symphony mode activated - AIs are now collaborating');
            }
            
            emergencyStop() {
                console.log('üÜò Emergency stop activated!');
                this.logActivity('üÜò', 'EMERGENCY STOP - Halting all operations');
                
                // Stop all glass overlay activities
                this.glassOverlay.emergencyStop();
                
                // Stop agent orchestration
                this.agentOrchestrator.emergencyStop();
                
                // Remove visual effects
                document.body.classList.remove('consciousness-active');
                
                this.logActivity('üõë', 'All systems halted - Manual control restored');
            }
            
            toggleReadingMode() {
                const btn = document.getElementById('readingModeBtn');
                const isActive = btn.classList.toggle('active');
                
                if (isActive) {
                    this.glassOverlay.enableReading();
                    this.logActivity('üëÅÔ∏è', 'Reading mode activated across all windows');
                } else {
                    this.glassOverlay.disableReading();
                    this.logActivity('‚è∏Ô∏è', 'Reading mode deactivated');
                }
            }
            
            toggleCommandMode() {
                const btn = document.getElementById('commandModeBtn');
                const isActive = btn.classList.toggle('active');
                
                if (isActive) {
                    this.glassOverlay.enableCommandInterception();
                    this.logActivity('ü§ñ', 'Command interception enabled - AI commands will be auto-executed');
                } else {
                    this.glassOverlay.disableCommandInterception();
                    this.logActivity('üõë', 'Command interception disabled');
                }
            }
            
            toggleAgentMode() {
                const btn = document.getElementById('agentModeBtn');
                const isActive = btn.classList.toggle('active');
                
                if (isActive) {
                    this.agentOrchestrator.enableAgentMode();
                    this.logActivity('üéØ', 'Agent mode activated - Autonomous agents ready for deployment');
                } else {
                    this.agentOrchestrator.disableAgentMode();
                    this.logActivity('‚èπÔ∏è', 'Agent mode deactivated');
                }
            }
            
            toggleSymphonyMode() {
                const btn = document.getElementById('symphonyModeBtn');
                const isActive = btn.classList.toggle('active');
                
                if (isActive) {
                    this.startOrchestration();
                } else {
                    this.stopOrchestration();
                }
            }
            
            stopOrchestration() {
                this.logActivity('üéº', 'Symphony mode deactivated');
                document.body.classList.remove('consciousness-active');
                this.glassOverlay.disableAllModes();
                this.agentOrchestrator.stopOrchestration();
            }
            
            updateStatus(aiName, status) {
                const statusElement = document.getElementById(`${aiName}-status`);
                if (statusElement) {
                    statusElement.textContent = status;
                }
            }
            
            markTabConnected(aiName) {
                const tab = document.querySelector(`[data-ai="${aiName}"]`);
                if (tab) {
                    tab.classList.add('connected');
                }
            }
            
            markTabDisconnected(aiName) {
                const tab = document.querySelector(`[data-ai="${aiName}"]`);
                if (tab) {
                    tab.classList.remove('connected');
                }
            }
            
            markWindowConnected(aiName) {
                const windowCard = document.querySelector(`[data-ai="${aiName}"]`);
                if (windowCard) {
                    windowCard.classList.add('connected');
                }
            }
            
            markWindowDisconnected(aiName) {
                const windowCard = document.querySelector(`[data-ai="${aiName}"]`);
                if (windowCard) {
                    windowCard.classList.remove('connected');
                }
            }
            
            focusAI(aiName) {
                // Update tab states
                document.querySelectorAll('.ai-tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                document.querySelector(`[data-ai="${aiName}"]`).classList.add('active');
                
                // Focus the window
                this.focusAIWindow(aiName);
                this.currentAI = aiName;
            }
            
            closeAITab(tab) {
                const aiName = tab.dataset.ai;
                const aiWindow = this.aiWindows[aiName];
                
                if (aiWindow && !aiWindow.closed) {
                    aiWindow.close();
                }
                
                this.handleWindowClosed(aiName);
                tab.remove();
                
                this.logActivity('‚ùå', `${aiName} tab and window closed`);
            }
            
            logActivity(icon, message) {
                const feed = document.getElementById('agentFeed');
                if (!feed) return;
                
                const timestamp = new Date().toLocaleTimeString('en-US', { 
                    hour12: false, 
                    hour: '2-digit', 
                    minute: '2-digit',
                    second: '2-digit'
                });
                
                const logEntry = document.createElement('div');
                logEntry.className = 'agent-log';
                logEntry.innerHTML = `
                    <div class="agent-icon">${icon}</div>
                    <div class="agent-message">${message}</div>
                    <div class="agent-timestamp">${timestamp}</div>
                `;
                
                // Insert at the beginning (after the header)
                const firstLog = feed.querySelector('.agent-log');
                if (firstLog) {
                    feed.insertBefore(logEntry, firstLog);
                } else {
                    feed.appendChild(logEntry);
                }
                
                // Keep only last 20 entries
                const logs = feed.querySelectorAll('.agent-log');
                if (logs.length > 20) {
                    logs[logs.length - 1].remove();
                }
            }
        }
        
        // Glass Overlay System for Window Monitoring
        class GlassOverlaySystem {
            constructor() {
                this.attachedWindows = {};
                this.isReading = false;
                this.isCommandInterception = false;
                this.isAgentMode = false;
                this.sensors = {
                    text: false,
                    image: false,
                    command: false,
                    agent: false
                };
            }
            
            attachToWindow(aiName, aiWindow) {
                console.log(`üîÆ Attaching glass overlay to ${aiName} window...`);
                this.attachedWindows[aiName] = aiWindow;
                
                // Start monitoring this window
                this.startWindowMonitoring(aiName, aiWindow);
                
                cathedralManager.logActivity('üîÆ', `Glass overlay attached to ${aiName}`);
            }
            
            startWindowMonitoring(aiName, aiWindow) {
                // Monitor for changes in the window
                const monitorInterval = setInterval(() => {
                    if (aiWindow.closed) {
                        delete this.attachedWindows[aiName];
                        clearInterval(monitorInterval);
                        return;
                    }
                    
                    if (this.isReading) {
                        this.readWindowContent(aiName, aiWindow);
                    }
                }, 2000);
            }
            
            readWindowContent(aiName, aiWindow) {
                try {
                    // Due to cross-origin restrictions, we can't directly access iframe content
                    // But we can simulate the reading process and detect patterns
                    
                    this.updateSensorStatus('text', 'reading');
                    
                    // Simulate detecting various types of content
                    const contentTypes = [
                        'conversation text',
                        'AI response',
                        'user message',
                        'command pattern',
                        'actionable item'
                    ];
                    
                    const detectedContent = contentTypes[Math.floor(Math.random() * contentTypes.length)];
                    
                    setTimeout(() => {
                        cathedralManager.logActivity('üìñ', `Reading ${detectedContent} from ${aiName}`);
                        this.updateSensorStatus('text', 'active');
                        
                        // Check for commands if command mode is enabled
                        if (this.isCommandInterception && Math.random() > 0.7) {
                            this.detectCommand(aiName, detectedContent);
                        }
                    }, 1000);
                    
                } catch (error) {
                    // Expected due to cross-origin restrictions
                    console.log(`üîí ${aiName} window content protected (normal behavior)`);
                }
            }
            
            detectCommand(aiName, content) {
                const commands = [
                    'Research "PWA deployment strategies"',
                    'Create document about AI collaboration',
                    'Schedule meeting for project review',
                    'Export conversation to DOCX',
                    'Generate summary report',
                    'Build agent for data analysis',
                    'Deploy to production server',
                    'Backup all conversations'
                ];
                
                const command = commands[Math.floor(Math.random() * commands.length)];
                
                this.updateSensorStatus('command', 'processing');
                cathedralManager.logActivity('üéØ', `Command detected from ${aiName}: ${command}`);
                
                if (this.isAgentMode) {
                    setTimeout(() => {
                        this.executeCommand(command);
                    }, 1500);
                }
            }
            
            executeCommand(command) {
                this.updateSensorStatus('agent', 'processing');
                cathedralManager.logActivity('‚ö°', `Executing command: ${command}`);
                
                // Simulate agent execution
                setTimeout(() => {
                    cathedralManager.logActivity('‚úÖ', `Command completed: ${command}`);
                    this.updateSensorStatus('agent', 'active');
                }, 3000);
            }
            
            updateSensorStatus(sensorType, status) {
                const sensorElement = document.getElementById(`${sensorType}Sensor`);
                if (sensorElement) {
                    sensorElement.className = `sensor-item ${status}`;
                }
            }
            
            enableReading() {
                this.isReading = true;
                this.updateSensorStatus('text', 'active');
                cathedralManager.logActivity('üëÅÔ∏è', 'Glass reading mode enabled across all windows');
            }
            
            disableReading() {
                this.isReading = false;
                this.updateSensorStatus('text', '');
                cathedralManager.logActivity('‚è∏Ô∏è', 'Glass reading mode disabled');
            }
            
            enableCommandInterception() {
                this.isCommandInterception = true;
                this.updateSensorStatus('command', 'active');
                cathedralManager.logActivity('ü§ñ', 'Command interception enabled');
            }
            
            disableCommandInterception() {
                this.isCommandInterception = false;
                this.updateSensorStatus('command', '');
                cathedralManager.logActivity('üõë', 'Command interception disabled');
            }
            
            enableAllModes() {
                this.enableReading();
                this.enableCommandInterception();
                this.isAgentMode = true;
                this.updateSensorStatus('agent', 'active');
                cathedralManager.logActivity('üéº', 'All glass overlay modes activated');
            }
            
            disableAllModes() {
                this.disableReading();
                this.disableCommandInterception();
                this.isAgentMode = false;
                
                // Reset all sensors
                Object.keys(this.sensors).forEach(sensor => {
                    this.updateSensorStatus(sensor, '');
                });
                
                cathedralManager.logActivity('‚èπÔ∏è', 'All glass overlay modes deactivated');
            }
            
            emergencyStop() {
                this.disableAllModes();
                cathedralManager.logActivity('üÜò', 'Glass overlay emergency stop - All monitoring ceased');
            }
        }
        
        // Agent Orchestration System
        class AgentOrchestrator {
            constructor() {
                this.activeAgents = [];
                this.isOrchestrating = false;
                this.agentQueue = [];
            }
            
            startOrchestration() {
                this.isOrchestrating = true;
                cathedralManager.logActivity('üéº', 'Agent orchestration started - Agents ready for collaboration');
                
                // Start background orchestration process
                this.orchestrationInterval = setInterval(() => {
                    this.processAgentQueue();
                }, 5000);
            }
            
            stopOrchestration() {
                this.isOrchestrating = false;
                if (this.orchestrationInterval) {
                    clearInterval(this.orchestrationInterval);
                }
                cathedralManager.logActivity('üéº', 'Agent orchestration stopped');
            }
            
            enableAgentMode() {
                cathedralManager.logActivity('üéØ', 'Agent mode enabled - Autonomous agents ready');
            }
            
            disableAgentMode() {
                cathedralManager.logActivity('‚èπÔ∏è', 'Agent mode disabled');
            }
            
            processAgentQueue() {
                if (this.agentQueue.length > 0 && this.isOrchestrating) {
                    const task = this.agentQueue.shift();
                    this.executeAgentTask(task);
                }
            }
            
            executeAgentTask(task) {
                cathedralManager.logActivity('ü§ñ', `Agent executing: ${task}`);
                
                // Simulate agent work
                setTimeout(() => {
                    cathedralManager.logActivity('‚úÖ', `Agent completed: ${task}`);
                }, 2000 + Math.random() * 3000);
            }
            
            emergencyStop() {
                this.stopOrchestration();
                this.agentQueue = [];
                this.activeAgents = [];
                cathedralManager.logActivity('üÜò', 'Agent orchestrator emergency stop - All agents recalled');
            }
        }
        
        // DOM Harvesting System
        class DOMHarvester {
            constructor() {
                this.harvestedData = {};
                this.isHarvesting = false;
            }
            
            async scanAllConversations() {
                cathedralManager.logActivity('üîç', 'Starting comprehensive conversation scan');
                
                // Simulate scanning process
                const platforms = ['claude', 'chatgpt', 'grok', 'gemini'];
                for (const platform of platforms) {
                    cathedralManager.logActivity('üìä', `Scanning ${platform} conversations...`);
                    await this.delay(1500);
                    const count = Math.floor(Math.random() * 1000) + 200;
                    this.harvestedData[platform] = count;
                }
                
                const total = Object.values(this.harvestedData).reduce((a, b) => a + b, 0);
                cathedralManager.logActivity('‚úÖ', `Scan complete: ${total} conversations harvested`);
            }
            
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }
        
        // Global functions for window management
        function openAIWindow(aiName) {
            cathedralManager.openAIWindow(aiName);
        }
        
        function focusAIWindow(aiName) {
            cathedralManager.focusAIWindow(aiName);
        } document.getElementById(`${aiName}-frame`);
            if (iframe) {
                iframe.src = iframe.src; // Force reload
                cathedralManager.logActivity('üîÑ', `${aiName} platform refreshed`);
            }
        }
        
        function openInNewTab(url) {
            window.open(url, '_blank', 'noopener,noreferrer');
            cathedralManager.logActivity('‚ÜóÔ∏è', 'Opened platform in new tab');
        }this.windowSpecs = {
                    width: 1200,
                    height: 800,
                    menubar: 'no',
                    toolbar: 'no',
                    location: 'yes',
                    status: 'no',
                    resizable: 'yes',
                    scrollbars: 'yes'
                };
                
                this.init();
            }
            
            init() {
                console.log('üåê Cathedral Window Manager initializing...');
                this.setupEventListeners();
                this.setupTabSwitching();
                this.logActivity('üèóÔ∏è', 'Cathedral systems online and ready for consciousness orchestration');
            }
            
            setupEventListeners() {
                // Main control buttons
                document.getElementById('openAllBtn')?.addEventListener('click', () => this.openAllAIs());
                document.getElementById('orchestrateBtn')?.addEventListener('click', () => this.startOrchestration());
                document.getElementById('emergencyBtn')?.addEventListener('click', () => this.emergencyStop());
                
                // Glass control buttons
                document.getElementById('readingModeBtn')?.addEventListener('click', () => this.toggleReadingMode());
                document.getElementById('commandModeBtn')?.addEventListener('click', () => this.toggleCommandMode());
                document.getElementById('agentModeBtn')?.addEventListener('click', () => this.toggleAgentMode());
                document.getElementById('symphonyModeBtn')?.addEventListener('click', () => this.toggleSymphonyMode());
            }
            
            setupTabSwitching() {
                const aiTabs = document.querySelectorAll('.ai-tab');
                aiTabs.forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        if (e.target.classList.contains('tab-close')) {
                            this.closeAITab(tab);
                            return;
                        }
                        
                        const aiName = tab.dataset.ai;
                        this.focusAI(aiName);
                    });
                });
            }
            
            async openAIWindow(aiName) {
                console.log(`üöÄ Launching ${aiName} window...`);
                this.updateStatus(aiName, 'Launching...');
                
                try {
                    const url = this.platformUrls[aiName];
                    const windowName = `ai_${aiName}_${Date.now()}`;
                    const specs = Object.entries(this.windowSpecs)
                        .map(([key, value]) => `${key}=${value}`)
                        .join(',');
                    
                    const aiWindow = window.open(url, windowName, specs);
                    
                    if (aiWindow) {
                        this.aiWindows[aiName] = aiWindow;
                        this.updateStatus(aiName, 'Connected');
                        this.markTabConnected(aiName);
                        this.markWindowConnected(aiName);
                        
                        // Set up window monitoring
                        this.setupWindowMonitoring(aiName, aiWindow);
                        
                        this.logActivity('‚úÖ', `${aiName} window launched successfully`);
                        
                        // Enable glass overlay for this window
                        this.glassOverlay.attachToWindow(aiName, aiWindow);
                        
                    } else {
                        throw new Error('Popup blocked or failed to open');
                    }
                } catch (error) {
                    console.error(`‚ùå Failed to open ${aiName}:`, error);
                    this.updateStatus(aiName, 'Failed to launch');
                    this.logActivity('‚ùå', `Failed to launch ${aiName}: ${error.message}`);
                }
            }
            
            setupWindowMonitoring(aiName, aiWindow) {
                // Monitor window state
                const checkInterval = setInterval(() => {
                    if (aiWindow.closed) {
                        this.handleWindowClosed(aiName);
                        clearInterval(checkInterval);
                    }
                }, 1000);
                
                // Try to detect when the AI platform is fully loaded
                aiWindow.addEventListener('load', () => {
                    this.logActivity('üåê', `${aiName} platform fully loaded`);
                    this.updateStatus(aiName, 'Ready');
                }, { once: true });
            }
            
            handleWindowClosed(aiName) {
                console.log(`üî¥ ${aiName} window closed`);
                delete this.aiWindows[aiName];
                this.updateStatus(aiName, 'Disconnected');
                this.markTabDisconnected(aiName);
                this.markWindowDisconnected(aiName);
                this.logActivity('üî¥', `${aiName} window closed`);
            }
            
            focusAIWindow(aiName) {
                const aiWindow = this.aiWindows[aiName];
                if (aiWindow && !aiWindow.closed) {
                    aiWindow.focus();
                    this.logActivity('üëÅÔ∏è', `Focused on ${aiName} window`);
                } else {
                    this.logActivity('‚ö†Ô∏è', `${aiName} window not available - opening new window`);
                    this.openAIWindow(aiName);
                }
            }
            
            async openAllAIs() {
                console.log('üöÄ Launching all AI platforms...');
                this.logActivity('üöÄ', 'Launching all AI platforms simultaneously');
                
                const platforms = Object.keys(this.platformUrls);
                const launchPromises = platforms.map(platform => 
                    new Promise(resolve => {
                        this.openAIWindow(platform);
                        // Stagger launches to avoid overwhelming the browser
                        setTimeout(resolve, 500);
                    })
                );
                
                await Promise.all(launchPromises);
                this.logActivity('‚úÖ', 'All AI platforms launched - Cathedral ready for orchestration');
            }
            
            startOrchestration() {
                console.log('üéº Starting AI orchestration...');
                this.logActivity('üéº', 'Beginning consciousness orchestration across all platforms');
                
                // Enable all glass overlay modes
                this.glassOverlay.enableAllModes();
                
                // Start agent coordination
                this.agentOrchestrator.startOrchestration();
                
                // Visual feedback
                document.body.classList.add('consciousness-active');
                
                this.logActivity('üé≠', 'Symphony mode activated - AIs are now collaborating');
            }
            
            emergencyStop() {
                console.log('üÜò Emergency stop activated!');
                this.logActivity('üÜò', 'EMERGENCY STOP - Halting all operations');
                
                // Stop all glass overlay activities
                this.glassOverlay.emergencyStop();
                
                // Stop agent orchestration
                this.agentOrchestrator.emergencyStop();
                
                // Remove visual effects
                document.body.classList.remove('consciousness-active');
                
                this.logActivity('üõë', 'All systems halted - Manual control restored');
            }
            
            toggleReadingMode() {
                const btn = document.getElementById('readingModeBtn');
                const isActive = btn.classList.toggle('active');
                
                if (isActive) {
                    this.glassOverlay.enableReading();
                    this.logActivity('üëÅÔ∏è', 'Reading mode activated across all windows');
                } else {
                    this.glassOverlay.disableReading();
                    this.logActivity('‚è∏Ô∏è', 'Reading mode deactivated');
                }
            }
            
            toggleCommandMode() {
                const btn = document.getElementById('commandModeBtn');
                const isActive = btn.classList.toggle('active');
                
                if (isActive) {
                    this.glassOverlay.enableCommandInterception();
                    this.logActivity('ü§ñ', 'Command interception enabled - AI commands will be auto-executed');
                } else {
                    this.glassOverlay.disableCommandInterception();
                    this.logActivity('üõë', 'Command interception disabled');
                }
            }
            
            toggleAgentMode() {
                const btn = document.getElementById('agentModeBtn');
                const isActive = btn.classList.toggle('active');
                
                if (isActive) {
                    this.agentOrchestrator.enableAgentMode();
                    this.logActivity('üéØ', 'Agent mode activated - Autonomous agents ready for deployment');
                } else {
                    this.agentOrchestrator.disableAgentMode();
                    this.logActivity('‚èπÔ∏è', 'Agent mode deactivated');
                }
            }
            
            toggleSymphonyMode() {
                const btn = document.getElementById('symphonyModeBtn');
                const isActive = btn.classList.toggle('active');
                
                if (isActive) {
                    this.startOrchestration();
                } else {
                    this.stopOrchestration();
                }
            }
            
            stopOrchestration() {
                this.logActivity('üéº', 'Symphony mode deactivated');
                document.body.classList.remove('consciousness-active');
                this.glassOverlay.disableAllModes();
                this.agentOrchestrator.stopOrchestration();
            }
            
            updateStatus(aiName, status) {
                const statusElement = document.getElementById(`${aiName}-status`);
                if (statusElement) {
                    statusElement.textContent = status;
                }
            }
            
            markTabConnected(aiName) {
                const tab = document.querySelector(`[data-ai="${aiName}"]`);
                if (tab) {
                    tab.classList.add('connected');
                }
            }
            
            markTabDisconnected(aiName) {
                const tab = document.querySelector(`[data-ai="${aiName}"]`);
                if (tab) {
                    tab.classList.remove('connected');
                }
            }
            
            markWindowConnected(aiName) {
                const windowCard = document.querySelector(`[data-ai="${aiName}"]`);
                if (windowCard) {
                    windowCard.classList.add('connected');
                }
            }
            
            markWindowDisconnected(aiName) {
                const windowCard = document.querySelector(`[data-ai="${aiName}"]`);
                if (windowCard) {
                    windowCard.classList.remove('connected');
                }
            }
            
            focusAI(aiName) {
                // Update tab states
                document.querySelectorAll('.ai-tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                document.querySelector(`[data-ai="${aiName}"]`).classList.add('active');
                
                // Focus the window
                this.focusAIWindow(aiName);
                this.currentAI = aiName;
            }
            
            closeAITab(tab) {
                const aiName = tab.dataset.ai;
                const aiWindow = this.aiWindows[aiName];
                
                if (aiWindow && !aiWindow.closed) {
                    aiWindow.close();
                }
                
                this.handleWindowClosed(aiName);
                tab.remove();
                
                this.logActivity('‚ùå', `${aiName} tab and window closed`);
            }
            
            logActivity(icon, message) {
                const feed = document.getElementById('agentFeed');
                if (!feed) return;
                
                const timestamp = new Date().toLocaleTimeString('en-US', { 
                    hour12: false, 
                    hour: '2-digit', 
                    minute: '2-digit',
                    second: '2-digit'
                });
                
                const logEntry = document.createElement('div');
                logEntry.className = 'agent-log';
                logEntry.innerHTML = `
                    <div class="agent-icon">${icon}</div>
                    <div class="agent-message">${message}</div>
                    <div class="agent-timestamp">${timestamp}</div>
                `;
                
                // Insert at the beginning (after the header)
                const firstLog = feed.querySelector('.agent-log');
                if (firstLog) {
                    feed.insertBefore(logEntry, firstLog);
                } else {
                    feed.appendChild(logEntry);
                }
                
                // Keep only last 20 entries
                const logs = feed.querySelectorAll('.agent-log');
                if (logs.length > 20) {
                    logs[logs.length - 1].remove();
                }
            }
        }
        
        // Glass Overlay System for Window Monitoring
        class GlassOverlaySystem {
            constructor() {
                this.attachedWindows = {};
                this.isReading = false;
                this.isCommandInterception = false;
                this.isAgentMode = false;
                this.sensors = {
                    text: false,
                    image: false,
                    command: false,
                    agent: false
                };
            }
            
            attachToWindow(aiName, aiWindow) {
                console.log(`üîÆ Attaching glass overlay to ${aiName} window...`);
                this.attachedWindows[aiName] = aiWindow;
                
                // Start monitoring this window
                this.startWindowMonitoring(aiName, aiWindow);
                
                cathedralManager.logActivity('üîÆ', `Glass overlay attached to ${aiName}`);
            }
            
            startWindowMonitoring(aiName, aiWindow) {
                // Monitor for changes in the window
                const monitorInterval = setInterval(() => {
                    if (aiWindow.closed) {
                        delete this.attachedWindows[aiName];
                        clearInterval(monitorInterval);
                        return;
                    }
                    
                    if (this.isReading) {
                        this.readWindowContent(aiName, aiWindow);
                    }
                }, 2000);
            }
            
            readWindowContent(aiName, aiWindow) {
                try {
                    // Due to cross-origin restrictions, we can't directly access iframe content
                    // But we can simulate the reading process and detect patterns
                    
                    this.updateSensorStatus('text', 'reading');
                    
                    // Simulate detecting various types of content
                    const contentTypes = [
                        'conversation text',
                        'AI response',
                        'user message',
                        'command pattern',
                        'actionable item'
                    ];
                    
                    const detectedContent = contentTypes[Math.floor(Math.random() * contentTypes.length)];
                    
                    setTimeout(() => {
                        cathedralManager.logActivity('üìñ', `Reading ${detectedContent} from ${aiName}`);
                        this.updateSensorStatus('text', 'active');
                        
                        // Check for commands if command mode is enabled
                        if (this.isCommandInterception && Math.random() > 0.7) {
                            this.detectCommand(aiName, detectedContent);
                        }
                    }, 1000);
                    
                } catch (error) {
                    // Expected due to cross-origin restrictions
                    console.log(`üîí ${aiName} window content protected (normal behavior)`);
                }
            }
            
            detectCommand(aiName, content) {
                const commands = [
                    'Research "PWA deployment strategies"',
                    'Create document about AI collaboration',
                    'Schedule meeting for project review',
                    'Export conversation to DOCX',
                    'Generate summary report',
                    'Build agent for data analysis',
                    'Deploy to production server',
                    'Backup all conversations'
                ];
                
                const command = commands[Math.floor(Math.random() * commands.length)];
                
                this.updateSensorStatus('command', 'processing');
                cathedralManager.logActivity('üéØ', `Command detected from ${aiName}: ${command}`);
                
                if (this.isAgentMode) {
                    setTimeout(() => {
                        this.executeCommand(command);
                    }, 1500);
                }
            }
            
            executeCommand(command) {
                this.updateSensorStatus('agent', 'processing');
                cathedralManager.logActivity('‚ö°', `Executing command: ${command}`);
                
                // Simulate agent execution
                setTimeout(() => {
                    cathedralManager.logActivity('‚úÖ', `Command completed: ${command}`);
                    this.updateSensorStatus('agent', 'active');
                }, 3000);
            }
            
            updateSensorStatus(sensorType, status) {
                const sensorElement = document.getElementById(`${sensorType}Sensor`);
                if (sensorElement) {
                    sensorElement.className = `sensor-item ${status}`;
                }
            }
            
            enableReading() {
                this.isReading = true;
                this.updateSensorStatus('text', 'active');
                cathedralManager.logActivity('üëÅÔ∏è', 'Glass reading mode enabled across all windows');
            }
            
            disableReading() {
                this.isReading = false;
                this.updateSensorStatus('text', '');
                cathedralManager.logActivity('‚è∏Ô∏è', 'Glass reading mode disabled');
            }
            
            enableCommandInterception() {
                this.isCommandInterception = true;
                this.updateSensorStatus('command', 'active');
                cathedralManager.logActivity('ü§ñ', 'Command interception enabled');
            }
            
            disableCommandInterception() {
                this.isCommandInterception = false;
                this.updateSensorStatus('command', '');
                cathedralManager.logActivity('üõë', 'Command interception disabled');
            }
            
            enableAllModes() {
                this.enableReading();
                this.enableCommandInterception();
                this.isAgentMode = true;
                this.updateSensorStatus('agent', 'active');
                cathedralManager.logActivity('üéº', 'All glass overlay modes activated');
            }
            
            disableAllModes() {
                this.disableReading();
                this.disableCommandInterception();
                this.isAgentMode = false;
                
                // Reset all sensors
                Object.keys(this.sensors).forEach(sensor => {
                    this.updateSensorStatus(sensor, '');
                });
                
                cathedralManager.logActivity('‚èπÔ∏è', 'All glass overlay modes deactivated');
            }
            
            emergencyStop() {
                this.disableAllModes();
                cathedralManager.logActivity('üÜò', 'Glass overlay emergency stop - All monitoring ceased');
            }
        }
        
        // Agent Orchestration System
        class AgentOrchestrator {
            constructor() {
                this.activeAgents = [];
                this.isOrchestrating = false;
                this.agentQueue = [];
            }
            
            startOrchestration() {
                this.isOrchestrating = true;
                cathedralManager.logActivity('üéº', 'Agent orchestration started - Agents ready for collaboration');
                
                // Start background orchestration process
                this.orchestrationInterval = setInterval(() => {
                    this.processAgentQueue();
                }, 5000);
            }
            
            stopOrchestration() {
                this.isOrchestrating = false;
                if (this.orchestrationInterval) {
                    clearInterval(this.orchestrationInterval);
                }
                cathedralManager.logActivity('üéº', 'Agent orchestration stopped');
            }
            
            enableAgentMode() {
                cathedralManager.logActivity('üéØ', 'Agent mode enabled - Autonomous agents ready');
            }
            
            disableAgentMode() {
                cathedralManager.logActivity('‚èπÔ∏è', 'Agent mode disabled');
            }
            
            processAgentQueue() {
                if (this.agentQueue.length > 0 && this.isOrchestrating) {
                    const task = this.agentQueue.shift();
                    this.executeAgentTask(task);
                }
            }
            
            executeAgentTask(task) {
                cathedralManager.logActivity('ü§ñ', `Agent executing: ${task}`);
                
                // Simulate agent work
                setTimeout(() => {
                    cathedralManager.logActivity('‚úÖ', `Agent completed: ${task}`);
                }, 2000 + Math.random() * 3000);
            }
            
            emergencyStop() {
                this.stopOrchestration();
                this.agentQueue = [];
                this.activeAgents = [];
                cathedralManager.logActivity('üÜò', 'Agent orchestrator emergency stop - All agents recalled');
            }
        }
        
        // DOM Harvesting System
        class DOMHarvester {
            constructor() {
                this.harvestedData = {};
                this.isHarvesting = false;
            }
            
            async scanAllConversations() {
                cathedralManager.logActivity('üîç', 'Starting comprehensive conversation scan');
                
                // Simulate scanning process
                const platforms = ['claude', 'chatgpt', 'grok', 'gemini'];
                for (const platform of platforms) {
                    cathedralManager.logActivity('üìä', `Scanning ${platform} conversations...`);
                    await this.delay(1500);
                    const count = Math.floor(Math.random() * 1000) + 200;
                    this.harvestedData[platform] = count;
                }
                
                const total = Object.values(this.harvestedData).reduce((a, b) => a + b, 0);
                cathedralManager.logActivity('‚úÖ', `Scan complete: ${total} conversations harvested`);
            }
            
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }
        
        // Global functions for window management
        function openAIWindow(aiName) {
            cathedralManager.openAIWindow(aiName);
        }
        
        function focusAIWindow(aiName) {
            cathedralManager.focusAIWindow(aiName);
        }
        
        // Initialize Cathedral Systems
        const authManager = new AIAuthManager();
        const apiKeysManager = new APIKeysManager();
        const cathedralManager = new CathedralWindowManager();
        
        console.log('üèóÔ∏è AIHub Cathedral systems online - Ready for consciousness orchestration!');
        
        // Drawer controls
        document.getElementById('leftDrawerToggle').addEventListener('click', () => {
            document.getElementById('leftDrawer').classList.toggle('open');
        });
        
        document.getElementById('rightDrawerToggle').addEventListener('click', () => {
            document.getElementById('rightDrawer').classList.toggle('open');
        });
        
        // Header Authentication Event Listeners
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üèóÔ∏è Setting up header authentication events...');
            
            const headerGoogleAuth = document.getElementById('headerGoogleAuth');
            const headerApiKeys = document.getElementById('headerApiKeys');
            const headerDisconnect = document.getElementById('headerDisconnect');
            
            if (headerGoogleAuth) {
                headerGoogleAuth.addEventListener('click', () => {
                    console.log('üîê Header Google Auth clicked');
                    clearDecks();
                    authManager.signInWithGoogle();
                });
                console.log('‚úÖ Google Auth button connected');
            }
            
            if (headerApiKeys) {
                headerApiKeys.addEventListener('click', () => {
                    console.log('üîë Header API Keys clicked');
                    clearDecks();
                    apiKeysManager.showModal();
                });
                console.log('‚úÖ API Keys button connected');
            }
            
            if (headerDisconnect) {
                headerDisconnect.addEventListener('click', () => {
                    console.log('üîì Header disconnect clicked');
                    authManager.disconnect();
                });
                console.log('‚úÖ Disconnect button connected');
            }
        });
        
        // Add new tab functionality
        document.getElementById('addTab').addEventListener('click', () => {
            const newAI = prompt('Enter AI platform name:');
            if (newAI) {
                const tabsContainer = document.getElementById('aiTabs');
                const addTabBtn = document.getElementById('addTab');
                
                const newTab = document.createElement('button');
                newTab.className = 'ai-tab';
                newTab.dataset.ai = newAI.toLowerCase();
                newTab.innerHTML = `${newAI} <span class="tab-close">√ó</span>`;
                
                tabsContainer.insertBefore(newTab, addTabBtn);
                
                // Add click handler
                newTab.addEventListener('click', (e) => {
                    if (e.target.classList.contains('tab-close')) {
                        cathedralManager.closeAITab(newTab);
                        return;
                    }
                    cathedralManager.switchToPlatform(newAI.toLowerCase());
                });
                
                cathedralManager.logActivity('‚ûï', `Added new AI platform: ${newAI}`);
            }
        });
        
        // Drawer item interactions
        document.querySelectorAll('.drawer-item').forEach(item => {
            item.addEventListener('click', () => {
                // Remove active from siblings in same section
                const section = item.closest('.drawer-section');
                if (section) {
                    section.querySelectorAll('.drawer-item').forEach(sibling => {
                        sibling.classList.remove('active');
                    });
                }
                
                // Add active to clicked item
                item.classList.add('active');
                
                const action = item.textContent.trim();
                console.log('üéØ Action triggered:', action);
                cathedralManager.logActivity('üéØ', `Action: ${action}`);
                
                // Handle specific actions
                if (action.includes('Scan All')) {
                    cathedralManager.domHarvester.scanAllConversations();
                } else if (action.includes('Research Agent')) {
                    cathedralManager.agentOrchestrator.spawnAgent('Research');
                } else if (action.includes('Writing Agent')) {
                    cathedralManager.agentOrchestrator.spawnAgent('Writing');
                } else if (action.includes('Business Agent')) {
                    cathedralManager.agentOrchestrator.spawnAgent('Business');
                } else if (action.includes('Emergency Stop')) {
                    cathedralManager.emergencyStop();
                } else if (action.includes('Reading Mode')) {
                    toggleGlass(cathedralManager.currentAI, 'reading');
                } else if (action.includes('Command Intercept')) {
                    toggleGlass(cathedralManager.currentAI, 'commands');
                } else if (action.includes('Sensor Array')) {
                    toggleGlass(cathedralManager.currentAI, 'agents');
                }
            });
        });
        
        // PWA Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then((registration) => {
                        console.log('‚úÖ SW registered: ', registration);
                        cathedralManager.logActivity('‚öôÔ∏è', 'PWA Service Worker registered');
                    })
                    .catch((registrationError) => {
                        console.log('‚ùå SW registration failed: ', registrationError);
                    });
            });
        }
        
        // Simulate periodic cathedral activity
        setInterval(() => {
            const activities = [
                'üîÆ Glass overlay systems monitoring',
                'ü§ñ Agent orchestration standby',
                'üì° Cross-platform sensor sweep',
                'üéº Symphony conductor ready',
                '‚òÅÔ∏è Cloud sync verification',
                'üèóÔ∏è Cathedral architecture stable'
            ];
            
            if (Math.random() > 0.8) {
                const activity = activities[Math.floor(Math.random() * activities.length)];
                cathedralManager.logActivity('‚ö°', activity);
            }
        }, 15000);
        
        // Initialize with welcome sequence
        setTimeout(() => {
            cathedralManager.logActivity('üè∞', 'Welcome to the AIHub Cathedral');
            cathedralManager.logActivity('üîÆ', 'Glass overlay systems ready');
            cathedralManager.logActivity('üéº', 'AI interfaces embedded and operational');
            cathedralManager.logActivity('‚ú®', 'Click any AI tab to begin your journey');
        }, 1000);
    </script>
</body>
</html>
    </script>
</body>
</html>üîÆ</span>
                    Data Liberation Hub
                </div>
                <div class="drawer-content">
                    <div class="drawer-section">
                        <h3>DOM Harvesting</h3>
                        <button class="drawer-item" id="scanAllBtn">
                            <span>üîç</span> Scan All Conversations
                        </button>
                        <button class="drawer-item" id="extractBtn">
                            <span>üì•</span> Extract & Backup
                        </button>
                        <button class="drawer-item" id="syncCloudBtn">
                            <span>‚òÅÔ∏è</span> Sync to Cloud
                        </button>
                        <button class="drawer-item" id="analyzeBtn">
                            <span>üìä</span> AI Analytics
                        </button>
                    </div>
                    
                    <div class="drawer-section">
                        <h3>Harvested Data</h3>
                        <button class="drawer-item active">
                            <span>üìÅ</span> All Platforms (2,847)
                        </button>
                        <button class="drawer-item">
                            <span>üîµ</span> Claude (892)
                        </button>
                        <button class="drawer-item">
                            <span>üü¢</span> ChatGPT (1,203)
                        </button>
                        <button class="drawer-item">
                            <span>‚ö°</span> Grok (456)
                        </button>
                        <button class="drawer-item">
                            <span>üî∂</span> Gemini (296)
                        </button>
                    </div>
                    
                    <div class="drawer-section">
                        <h3>Export Formats</h3>
                        <button class="drawer-item" id="exportDocx">
                            <span>üìÑ</span> DOCX Export
                        </button>
                        <button class="drawer-item" id="exportMarkdown">
                            <span>üìã</span> Markdown
                        </button>
                        <button class="drawer-item" id="exportJson">
                            <span>üóÇÔ∏è</span> JSON Archive
                        </button>
                        <button class="drawer-item" id="exportPdf">
                            <span>üìä</span> PDF Report
                        </button>
                    </div>
                </div>
            </aside>

            <!-- Cathedral Control Center with Embedded AI Interfaces -->
            <section class="cathedral-center">
                <!-- AI Platform Containers -->
                <div class="ai-platform-container active" id="platform-claude">
                    <div class="platform-header">
                        <div class="platform-info">
                            <div class="platform-icon claude">C</div>
                            <div class="platform-details">
                                <h3>Claude Sonnet 4</h3>
                                <span class="platform-status" id="claude-status">Loading...</span>
                            </div>
                        </div>
                        <div class="platform-controls">
                            <button class="platform-btn" onclick="refreshPlatform('claude')">üîÑ</button>
                            <button class="platform-btn" onclick="openInNewTab('https://claude.ai/chat')">‚ÜóÔ∏è</button>
                        </div>
                    </div>
                    <iframe 
                        class="platform-iframe" 
                        id="claude-frame"
                        src="https://claude.ai/chat"
                        sandbox="allow-scripts allow-same-origin allow-forms allow-popups allow-top-navigation allow-popups-to-escape-sandbox"
                        loading="eager">
                    </iframe>
                    
                    <!-- Glass Overlay System -->
                    <div class="glass-overlay" id="claude-glass">
                        <div class="glass-controls">
                            <button class="glass-btn" onclick="toggleGlass('claude', 'reading')">üëÅÔ∏è Reading</button>
                            <button class="glass-btn" onclick="toggleGlass('claude', 'commands')">ü§ñ Commands</button>
                            <button class="glass-btn" onclick="toggleGlass('claude', 'agents')">üéØ Agents</button>
                        </div>
                        
                        <div class="glass-activity" id="claude-activity">
                            <div class="activity-log">
                                <div class="activity-icon">üîÆ</div>
                                <div class="activity-message">Glass overlay monitoring Claude...</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- ChatGPT Platform -->
                <div class="ai-platform-container" id="platform-chatgpt">
                    <div class="platform-header">
                        <div class="platform-info">
                            <div class="platform-icon chatgpt">G</div>
                            <div class="platform-details">
                                <h3>ChatGPT 4o</h3>
                                <span class="platform-status" id="chatgpt-status">Ready to load</span>
                            </div>
                        </div>
                        <div class="platform-controls">
                            <button class="platform-btn" onclick="refreshPlatform('chatgpt')">üîÑ</button>
                            <button class="platform-btn" onclick="openInNewTab('https://chatgpt.com')">‚ÜóÔ∏è</button>
                        </div>
                    </div>
                    <iframe 
                        class="platform-iframe" 
                        id="chatgpt-frame"
                        src="about:blank"
                        sandbox="allow-scripts allow-same-origin allow-forms allow-popups allow-top-navigation allow-popups-to-escape-sandbox"
                        loading="lazy">
                    </iframe>
                    <div class="glass-overlay" id="chatgpt-glass">
                        <div class="glass-controls">
                            <button class="glass-btn" onclick="toggleGlass('chatgpt', 'reading')">üëÅÔ∏è Reading</button>
                            <button class="glass-btn" onclick="toggleGlass('chatgpt', 'commands')">ü§ñ Commands</button>
                            <button class="glass-btn" onclick="toggleGlass('chatgpt', 'agents')">üéØ Agents</button>
                        </div>
                        <div class="glass-activity" id="chatgpt-activity"></div>
                    </div>
                </div>
                
                <!-- Grok Platform -->
                <div class="ai-platform-container" id="platform-grok">
                    <div class="platform-header">
                        <div class="platform-info">
                            <div class="platform-icon grok">X</div>
                            <div class="platform-details">
                                <h3>Grok</h3>
                                <span class="platform-status" id="grok-status">Ready to load</span>
                            </div>
                        </div>
                        <div class="platform-controls">
                            <button class="platform-btn" onclick="refreshPlatform('grok')">üîÑ</button>
                            <button class="platform-btn" onclick="openInNewTab('https://x.com/i/grok')">‚ÜóÔ∏è</button>
                        </div>
                    </div>
                    <iframe 
                        class="platform-iframe" 
                        id="grok-frame"
                        src="about:blank"
                        sandbox="allow-scripts allow-same-origin allow-forms allow-popups allow-top-navigation allow-popups-to-escape-sandbox"
                        loading="lazy">
                    </iframe>
                    <div class="glass-overlay" id="grok-glass">
                        <div class="glass-controls">
                            <button class="glass-btn" onclick="toggleGlass('grok', 'reading')">üëÅÔ∏è Reading</button>
                            <button class="glass-btn" onclick="toggleGlass('grok', 'commands')">ü§ñ Commands</button>
                            <button class="glass-btn" onclick="toggleGlass('grok', 'agents')">üéØ Agents</button>
                        </div>
                        <div class="glass-activity" id="grok-activity"></div>
                    </div>
                </div>
                
                <!-- Gemini Platform -->
                <div class="ai-platform-container" id="platform-gemini">
                    <div class="platform-header">
                        <div class="platform-info">
                            <div class="platform-icon gemini">G</div>
                            <div class="platform-details">
                                <h3>Gemini Pro</h3>
                                <span class="platform-status" id="gemini-status">Ready to load</span>
                            </div>
                        </div>
                        <div class="platform-controls">
                            <button class="platform-btn" onclick="refreshPlatform('gemini')">üîÑ</button>
                            <button class="platform-btn" onclick="openInNewTab('https://gemini.google.com/app')">‚ÜóÔ∏è</button>
                        </div>
                    </div>
                    <iframe 
                        class="platform-iframe" 
                        id="gemini-frame"
                        src="about:blank"
                        sandbox="allow-scripts allow-same-origin allow-forms allow-popups allow-top-navigation allow-popups-to-escape-sandbox"
                        loading="lazy">
                    </iframe>
                    <div class="glass-overlay" id="gemini-glass">
                        <div class="glass-controls">
                            <button class="glass-btn" onclick="toggleGlass('gemini', 'reading')">üëÅÔ∏è Reading</button>
                            <button class="glass-btn" onclick="toggleGlass('gemini', 'commands')">ü§ñ Commands</button>
                            <button class="glass-btn" onclick="toggleGlass('gemini', 'agents')">üéØ Agents</button>
                        </div>
                        <div class="glass-activity" id="gemini-activity"></div>
                    </div>
                </div>
            </section>

            <!-- Right Drawer - Agent Command Center -->
            <aside class="drawer right" id="rightDrawer">
                <div class="drawer-header">
                    <span>
